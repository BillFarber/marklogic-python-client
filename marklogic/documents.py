import json

from requests import Session
from urllib3.fields import RequestField
from urllib3.filepost import encode_multipart_formdata


class Document:
    """
    :param uri: the URI of the document; can be None when relying on MarkLogic to
    generate a URI.
    :param content: the content of the document.
    :param collections: array of collection URIs.
    :param permissions: dict with keys of role names and values of arrays of
    capabilities such as "read", "update", and "execute".
    :param quality: document quality, used for scoring in searches.
    :param metadata_values: dict with string keys and string values.
    :param properties: dict with string keys and values of any type.
    :param content_type: the MIME type of the document; use when MarkLogic cannot
    determine the MIME type based on the URI.
    :param extension: specifies a suffix for a URI generated by MarkLogic.
    :param directory: specifies a prefix for a URI generated by MarkLogic.
    :param repair: for an XML document, the level of XML repair to perform; can be
    "full" or "none", with "none" being the default.
    :param version_id: affects updates when optimistic locking is enabled; see
    https://docs.marklogic.com/REST/POST/v1/documents for more information.
    :param temporal_document: the logical document URI for a document written to a
    temporal collection; requires that a "temporal-collection" parameter be included in
    the request.
    """

    def __init__(
        self,
        uri: str,
        content,
        collections: list[str] = None,
        permissions: dict = None,
        quality: int = None,
        metadata_values: dict = None,
        properties: dict = None,
        content_type: str = None,
        extension: str = None,
        directory: str = None,
        repair: str = None,
        extract: str = None,
        version_id: str = None,
        temporal_document: str = None,
    ):
        self.uri = uri
        self.content = content
        self.collections = collections
        self.permissions = permissions
        self.quality = quality
        self.metadata_values = metadata_values
        self.properties = properties

        # The following are all specific to writing a document.
        self.content_type = content_type
        self.extension = extension
        self.directory = directory
        self.repair = repair
        self.extract = extract
        self.version_id = version_id
        self.temporal_document = temporal_document

    def to_request_field(self) -> RequestField:
        data = self.content
        if type(data) is dict:
            data = json.dumps(data)
        field = RequestField(name=self.uri, data=data, filename=self.uri)
        field.make_multipart(
            content_disposition=self._make_disposition(),
            content_type=self.content_type,
        )
        return field

    def to_metadata_dict(self) -> dict:
        """
        Returns a dictionary with a data structure matching what the /v1/documents
        endpoint requires.
        """
        metadata = {}
        if self.permissions:
            metadata["permissions"] = [
                {"role-name": k, "capabilities": v} for k, v in self.permissions.items()
            ]
        if self.collections:
            metadata["collections"] = self.collections
        if self.quality:
            metadata["quality"] = self.quality
        if self.properties:
            metadata["properties"] = self.properties
        if self.metadata_values:
            metadata["metadataValues"] = self.metadata_values
        return metadata

    def to_metadata_request_field(self) -> RequestField:
        metadata = self.to_metadata_dict()
        if len(metadata.keys()) == 0:
            return None

        field = RequestField(
            name=self.uri, data=json.dumps(metadata), filename=self.uri
        )
        field.make_multipart(
            content_disposition=f"attachment; filename={self.uri}; category=metadata",
            content_type="application/json",
        )
        return field

    def _make_disposition(self) -> str:
        disposition = "attachment"

        if not self.uri:
            disposition = "inline"
            if self.extension:
                disposition = f"{disposition};extension={self.extension}"
            if self.directory:
                disposition = f"{disposition};directory={self.directory}"

        if self.repair:
            disposition = f"{disposition};repair={self.repair}"

        if self.extract:
            disposition = f"{disposition};extract={self.extract}"

        if self.version_id:
            disposition = f"{disposition};versionId={self.version_id}"

        if self.temporal_document:
            disposition = f"{disposition};temporal-document={self.temporal_document}"

        return disposition


class DocumentManager:
    def __init__(self, session: Session):
        self._session = session

    def write(self, documents: list[Document], **kwargs):
        fields = []
        for doc in documents:
            metadata_field = doc.to_metadata_request_field()
            if metadata_field:
                fields.append(metadata_field)
            fields.append(doc.to_request_field())

        data, content_type = encode_multipart_formdata(fields)

        headers = kwargs.pop("headers", {})
        headers["Content-Type"] = "".join(
            ("multipart/mixed",) + content_type.partition(";")[1:]
        )
        if not headers.get("Accept"):
            headers["Accept"] = "application/json"

        return self._session.post("/v1/documents", data=data, headers=headers, **kwargs)
